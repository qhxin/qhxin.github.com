[{"title":"在树莓派上安装 Node.js 的指引 | thisDaveJ","date":"2016-12-19T14:26:37.120Z","path":"2016/12/19/fanyi/beginners-guide-to-installing-node-js-on-a-raspberry-pi/","text":"这篇文章已经更新了，包涵了 Node 最近一个版本的安装，在写这篇文章的时候是 Node 7.x。 在我们这批LTM（Learning through Making）Node.js系列教程，我们将在树莓派3或者2上准备和运行 Node。在树莓派3上，你不需要购买独立的USB Wi-Fi适配器。我专注于树莓派3和2，而不是老版本的诸如树莓派B+，因为在写这篇文章时它们是最新的型号。在树莓派3，举个例子来说，它有一个 1.2GHz 的四核 ARMv8 芯片和 1GB 的内存，相比起来，树莓派1的B+型号只有 700MHz 的单核 ARMv6 芯片以及 512MB 的内存。 这里提供的介绍是为在树莓派3（ARMv8）或者树莓派2（ARMv7）上安装 Node.js 准备的而不是其它的基于 ARMv6 芯片的型号，诸如树莓派1的B型号、B+型号或者树莓派0。这个安装指南的大部分应该仍然被证明对除了派2和派3以外的其它树莓派系统是有用的；然而，最后的步骤重点在于它不会在基于老 ARMv6 架构的系统上工作。本教程对于任何希望成功安装树莓派2或3系统的人都是有用的，即使他们对于 Node.js 并不感兴趣，因为 Node.js 的安装发生在本教程的最后一步。但是，为什么你不想安装 Node.js呢？让我们开始吧！ 内容目录 需要的硬件 写 Raspbian 镜像像到SD卡 准备硬件 配置 RasPi 配置 Wi-Fi 应用 Raspbian 的更新 准备远程桌面 在 RasPi 创建 Windows 文件共享（可选） 安装 Node.js 下一次 需要的硬件如果你现在没有树莓派，最简单的方法是购买一个入门套件，如亚马逊上的这一个： CanaKit Raspberry Pi 3 完整的初学者套件 – 32 GB 版 （注：我的会员信息包括在亚马逊链接里，所以你可以，如果你想，支持这些教程而不用付出额外的消费。） 我们需要以下项目来作为开始： 树莓派3的型号B或者树莓派2的型号B（这些都是树莓派3和2的官方的名字。不要让“B”混淆你，因为还有一个老的树莓派型号B，现在实际上是“树莓派1型号B”。） MicroSD卡（我推荐一个 CLASS10 的卡，它是 16 GB 或更高。我喜欢这个三星 32GB Class 10 microSD card。） MicroSD 转 SD 存储卡适配器（因此，你可以使用 SD 读卡器在你的笔记本/桌面电脑写入 MicroSD 卡。如下所示，有许多的 microSD 卡供应商在购买的时候包含SD适配器。） 微型 USB 电源（推荐 2.5A 或者更大）为 RasPi 供电。 （仅在 RasPi 2 需要）USB WiFi 网卡（或优先以太网电缆的。我已经在树莓派上测试过这个Edimax USB WiFi 网卡，并且它工作得非常好。这是一个它在亚马逊畅销的原因。）在树莓派3上因为有内置 Wi-Fi 所以不需要它。 Windows 笔记本电脑/台式机（Linux 或者 Mac 也能极好的工作，但是本教程面向Windows机器，所以一些读者将需要调整） HDMI显示器、USB键盘/鼠标（你可以从另一个系统暂时借用这些设备，然后运行你的 RasPi 在无外设模式，稍后我会解释。） 一旦你收集所需的硬件，我们准备好了让我们的 RasPi 苏醒了！ 将 Raspbian 镜像写入 SD 卡我们将运行 Raspbian，这是一个基于 Debian Linux 的免费操作系统并且为树莓派做了优化。让我们开始吧： 从 https://www.raspberrypi.org/downloads/raspbian/ 下载最新的 Raspbian 镜像。请下载完整版本，而不是“精简”版。下载的是一个ZIP文件，约1.5 GB，所以它可能需要一些时间下载，这取决于你的互联网连接速度。 插入microSD卡到SD适配器，就像在上面的三星示例图片所示的那样。 将 SD 卡适配器插到笔记本电脑/桌面电脑的 SD读卡器。确保它很好的连接固定了。 启动Windows资源管理器，并验证SD卡作为驱动器在您的系统上注册。请注意驱动器盘符，因为你很快将需要它。 下载并安装 Etcher。Etcher是一个跨平台（Windows，OS X，Linux）的闪存镜像到SD卡的工具。它有许多很棒的功能，包括一个简单的用户界面、闪存镜像而不需要解压zip文件的能力、以及一个验证步骤用于验证SD卡镜像是否正确写入SD卡。 （对于 Windows 用户来说有一个可供替代的选择，你可以使用 Win32 磁盘镜像，因为它也提供了读取SD卡、并创建一个镜像文件的能力，这对于创建树莓派系统的快照是很方便的，如果需要的话，这个快照也可以被闪存回SD卡。对于Win32 磁盘镜像，你需要在往你的正确的SD卡盘符烧写.img文件之前，先解压这个下载的zip文件） 启动 Etcher。要有耐心，Etcher 需要数秒启动。启动后，界面看起来像这样： 点击 Select image（选择镜像）按钮，找到你下载的 Raspbian 的 zip 文件。（在烧写之前不需要解压。） 点击 Select drive（选择驱动器）按钮，指定 SD 卡的目标设备位置。 警告：请确定你选择了正确的目标设备，否则你会将镜像写入到你系统的另一个驱动器，这将是不妙的。 点击 Flash 按钮，将镜像写到 SD 卡上。 如果你正在运行Windows，可能会出现有关更改设备的安全提示。如果是这样的话，请单击“Yes”继续进行。 当镜像被写入SD卡和通过验证之后，Etcher会自动卸载你的SD卡，它可以安全地被移除。 从你的笔记本电脑/台式机取出SD适配器，并从SD适配器移除microSD卡。 准备硬件Tech Brick Café有一个很好的树莓派2各部分的概览图在这里（树莓派3看起来非常相似），这可能会在这一部分内容里帮助你。让我们这个小小的SBC（single board computer）准备启动！这里是步骤： 插入microSD卡到树莓派。（把树莓派颠倒。microSD卡槽位于USB端口对面那一侧。这个短视频很好地解释了这个过程。） 连接USB键盘和鼠标 连接HDMI线 连接USB Wi-Fi适配器（或以太网连接，如果你不使用Wi-Fi），如果你使用的是树莓派3，这一步是没有必要的，有内置Wi-Fi。 接通电源（你会看到树莓派灯亮并通电了。） 你现在应该看到树莓派在屏幕上启动。万岁! 配置树莓派我们首先需要做一些 RasPi 的改动，为的是为我们的使用进行优化和个性化。开始，启动树莓派配置程序，它位于Preferences下面的菜单里。 这将启动树莓派配置程序，这是基于控制台配置程序的一个方便的图形版本，这个控制台程序已经被使用多年用来配置树莓派（实际上，这个控制台程序仍然用于这个图形版本幕后使用）。这将启动以下窗口： 让我们开始配置吧！ Expand Filesystem（扩展文件系统）——单击此按钮可扩展文件系统。这将确保所有的SD卡存储对 Raspbian 可用。 （可选）Change Password（更改密码）——从安全的角度，改变“pi”用户的默认密码是个好主意。只要确保你不忘记它。 😉 Hostname（主机名）——如果远程连接时你喜欢打更少的字（在后面有解释），您可以更改主机名称“raspberrypi”更短一些，如“raspi”。 本地化树莓派是我们英国朋友的精彩创意。如果您不是来自英国，你将需要更改一些本地化设置。例如，键盘上的某些键可能无法按预期的方式工作。这是我在圣地亚哥做的一些改动，这让我的树莓派更加舒适： 首先，单击 Localisation 选项卡: 点击 Set Locale 按钮，更改你的区域为适当的设置然后点击 OK。在更改设置后，我的看起来就像这样： 点击 Set Timezone 按钮，设置你的时区，然后点击 OK。 点击 Set Keyboard 按钮，更改你的键盘为合适的设置，然后点击 OK。这是我的： 最后，点击 Set WiFi Country 按钮并按需要更改设置。这个对话框列出了大量的国家列表。用你的键盘上的箭头键滚动列表找到你的国家然后点击 OK。 完成这些配置步骤后，点击 OK 退出树莓派配置程序。树莓派然后将通知你它需要重启以便激活你刚才的设置。现在重新启动它。 配置Wi-Fi在树莓派重启后，我们已经准备和运行 Wi-Fi 以获得网络。 点击屏幕右上方的网络图标，如截图所示。在Wi-Fi配置之前，网络图标将与截图中的图标不同；但是，它应该位于蓝牙图标和扬声器（音量控制）图标之间。 在点击网络图标之后，选择你的网络SSID（Wi-Fi网络）。如果你没有看到你的Wi-Fi网络，请耐心等待。你可能会在菜单里看到一个“Scanning APs（扫描AP）”的消息；然而当它找出后，你的Wi-Fi网络SSID应该最终出现在菜单里。当你的网络的名称出现后，点击它。 你将被提示输入你的预共享（Wi-Fi）网络密码。输入它然后选择 OK。 等待图标从网络图标转换到上面截图里显示的Wi-Fi图标。从这一点判断，你应该已经连接上了你的Wi-Fi网络。 通过启动终端测试您的Wi-Fi网络连接。 从终端，发出ping命令，以验证您的网络连接正在工作： 1$ ping google.com 我们现在准备继续前进，确保我们的系统是最新的安全补丁 应用Raspbian的更新我们将首先运行apt的“update”命令。此命令将不会实际更新系统上的任何软件，但将下载最新的软件包列表的软件库，这样 Raspbian 就可以可以随着依赖了解所有的新软件。在“$”提示下发出以下命令： 1$ sudo apt update 接下来，运行以下命令来升级安装在您的系统上需要升级的任何包： 1$ sudo apt full-upgrade 保持你的树莓派系统同步安全更新是很重要的。这两个命令应该一起发出并定期运行。 准备远程桌面我们要远程运行我们的树莓派，无需专用的HDMI显示器和USB键盘/鼠标。这被称为无外设模式。我们将使用xrdp包来实现这一目标。新版本的Raspbian（从带有 PIXEL 桌面环境的版本开始）为远程连接功能装载有RealVNC。不幸的是，RealVNC不能很好地工作在无外设方式因为它降级到一个非常低的分辨率，而且改变分辨率有相当多的步骤。我们的xrdp方案自动缩放桌面分辨率，使我们的更容易使用。让我们这样做： 我们可以安装xrdp之前，我们必须先安装tightvncserver包。tightvncserver的安装也将删除最新版本的Raspbian装载的RealVNC服务器软件，因为如果安装了RealVNC，tightvncserver（xrdp）不会工作。（感谢Ryan Hanley的提示！）在终端输入下面的命令： 1$ sudo apt install -y tightvncserver “-y”选项将自动用“是”回答默认的问题，这是我们在这种情况下想要的。 下一步，调用下面的命令来安装xrdp： 1$ sudo apt install -y xrdp 最后，我们需要安装 samba 包，我们将能够从网络上的 Windows 机器通过主机名 raspi 访问树莓派，而不是通过IP地址，因为树莓派会通过 DHCP 改变它的 IP 地址。（对于OS X用户，你可以安装Bonjour然后访问你的树莓派的主机名。例如，如果你的主机名是“raspi”，你可以在OS X上以“raspi.local”访问它。）好了，让我们安装Samba： 1$ sudo apt install -y samba 安装完成后，你应该可以从Windows机器上ping这个树莓派的主机名（上面树莓派配置程序里配置的那个）： 1C:\\&gt; ping raspi 现在你已准备好了启动远程桌面连接！ 在你的Windows机器上，点击Windows键，输入“Remote Desktop Connection”（远程桌面连接）调出远程桌面程序。点击它来启动它。（OS X用户可以使用Microsoft Remote Desktop，这在Mac应用商店是免费的。） 在 Computer 文本框输入你的树莓派的主机名（在我的情况下是“raspi”）。 然后，点击 Display 标签。移动 Display configuration 滑块到右边的“Full Screen”来保证我们的远程桌面连接将填补我的屏幕。它有可能已经被设置为“Full Screen”。 点击靠近对话框底部的 Connect 按钮。 然后你将被xrdp的登录屏幕提示： 输入您的凭据登录到树莓派。 用户名：pi 密码：raspberry（除非你在之前的教程里的树莓派配置程序里改变了它。） 太神了！我们远程连接到了 RasPi，我们不再需要专用的HDMI显示器和USB键盘/鼠标。让我们先关闭 RasPi 一分钟，这样我们可以释放我们的显示器和键盘/鼠标： 启动一个终端会话并输入下面的命令来关闭您的系统： 1$ sudo poweroff 等待的 RasPi 完全断电。 拔掉电源线，HDMI线，USB键盘和鼠标。 把插头电源线接回来，RasPi 应该会重新启动，但没有那些多余的连线！ 给了 RasPi 一分钟左右开机之后，再次使用Windows远程桌面程序连接到它。 在RasPi创建 Windows 文件共享（可选）我们可以在RasPi创建一个Windows文件共享，使我们能从Windows机器上直接复制文件到RasPi。这可以在许多情况下派上用场。对于OS X用户这也是有用的，因为你将能够从“Shared”的Finder连接到您的树莓派文件共享。这是我们如何做的： 启动一个终端会话。 如下在主目录中创建一个名为“share”的目录： 1$ mkdir ~/share 发出以下命令来启动Leafpad编辑器。 1$ sudo leafpad /etc/samba/smb.conf &amp; 我们也可以使用基于控制台的“nano”编辑器，但Leafpad提供一个GUI，比较适合初学者。在启动Leafpad的命令结尾的“&amp;”符号让Leafpad成为后台进程，让我们回到终端shell提示符。同时，smb.conf 是我们之前安装的Samba软件包的一部分，这就是为什么它会存在在我们的系统里。 向下滚动到smb.conf配置文件的底部并添加下面的配置： 123456789[PiShare] comment=Raspi Share path=/home/pi/share browseable=Yes writeable=Yes only guest=No create mask=0740 directory mask=0750 public=no 保存smb.conf配置文件的修改并退出Leafpad编辑器。（Raspbian将自动重启基于您的配置文件所做的更改的SMB（Samba）服务。） 回到终端会话，我们需要创建一个SMB（Samba）用户可以让我们安全地从Windows连接。我们将创建一个名为“pi”的用户，但这将是一个SMB（Windows用户）而不是Raspbian的“pi”的用户。这是我们如何做的： 1$ sudo smbpasswd -a pi 你会被提示输入并重新输入密码。将此密码记录在某处以备将来查阅。 我们已经准备好了从Windows连接到我们新创建的RasPi文件共享！ 回到你的Windows机器，键入Windows键和“R”（Win-R）启动输入命令的运行对话框。 输入两个反斜杠后跟你的 RasPi 机器名（例如：你的主机名）并且敲下回车。例如： 1\\\\raspi 提示凭据时，输入以下内容： 用户名：以Windows语法输入的格式是域\\用户名。对我们来说，我们的域是我们RasPi的主机名、用户名是“pi”。因此，我们将输入：raspi\\pi 如果你的名字是不是raspi，你显然应该用你的替换它来输入。 密码：（输入你上面用smbpasswd命令创建的密码） 瞧！我们现在应该连接上了。双击 PiShare 文件夹启动你刚才创建的文件分享。你也会看到一个叫做pi的文件夹，它给你的整个主目录提供只读权限。 你可以通过在Windows端创建一个文本文件，并验证它出现在 RasPi 端的目录 /home/pi/share 里，这样来测试你新创建的文件共享。 在Windows中，还可以将驱动器映射到刚刚创建的文件共享： 启动窗口资源管理器。 点击在顶部带状菜单的 Map network drive （映射网络驱动器）按钮并选择映射到网络驱动器。 输入驱动器盘符（比如“pi”驱动器的“P”盘符）、共享目录路径、并选择在登录时重新连接： 输入上面你用smbpasswd命令创建的密码（如果被提示输入的话），选择 Remember my credentials（记住我的凭证）： 在通过窗口浏览器查看时，你现在应该能看到一个“P”驱动器（或者其他你选择的驱动器盘符）！ 安装 Node.js您现在有一个惊艳的通用树莓派系统，可用于各种任务，并在Windows世界中运行良好（它甚至和其他Windows机器看起来就像是一个Windows机器！）——而且也可以很好地在Mac和Linux世界里工作。让我们继续安装Node.js，我们将准备在未来做一些有趣的项目。这里是步骤： 我们在NodeSource的朋友主办并维护一些优秀的Node.js的二进制分发。我们将利用一个他们写的命令添加另一个包管理库到我们的RasPi，所以，我们可以从他们的仓库“apt install”一个现代版的Node.js。这是有益的因为Debian / Raspbian版本可能不会永远是最新的。通过添加 NodeSource 库，我们也将能够接收更新，而不是仅仅安装一个不容易升级的 Node 版本的独立的（.deb）文件。 注：如本文开头介绍的，最后这部分对Node.js安装相关的教程，要求基于新的ARMv7或ARMv8芯片诸如树莓派2和树莓派3的系统。NodeSource 提供 Node.js 的二进制文件给ARMv7+的架构，但不支持基于旧的ARMv6架构的树莓派系统，诸如树莓派B/B+型号，或者树莓派0。 仔细阅读你的树莓派电路板，确认写的是类似“Raspberry Pi 3 Model B”或者“Raspberry Pi 2 Model B”的东西。如果有疑问，在终端中运行以下命令： 12&gt; $ uname -m&gt; 如果返回的结果以“armv6”开头，你正在运行一个基于旧的ARMv6芯片的树莓派，并且后面的 Node.js 安装步骤不会成功；否则，你已经准备好了下一步。 这里我们来到了最后的时段！让我们继续进行安装 Node 的最新版本，Node 7.2.1。 1$ curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash - 前面的命令修改我们的Debian的apt包管理库引用NodeSource包。 注：从安全的角度来看知道你在系统上调用了什么命令通常是一个好想法，特别是因为上面的命令以root用户调用脚本。如果你希望知道这个脚本后面的技术细节，你可以在浏览器打开这个网址(https://deb.nodesource.com/setup_7.x)，然后审查代码。这个脚本执行一些步骤以确定正在运行的Linux发行版，并指示Debian apt包管理系统添加NodeSource包仓库作为一个值得信赖的来源以获取Debian软件包。这让我们现在可以安装 Node.js 并且可以升级到最新版本的可用Node.js。 现在，我们已经添加了 NodeSource 包仓库，我们可以继续安装Node.js了！ 1$ sudo apt install nodejs 然后我们可以测试和查看我们正在运行的 Node 版本，并且启动 Node 控制台，就像我们在前一篇文章里讨论的那样，作为一个快速测试，以确认安装成功。 123456$ node -vv7.2.1$ node&gt; 1 + 34&gt; # 我们可以敲两次 Ctrl-C 来退出控制台，返回 shell 提示符。 下一次在以后的文章中，我们将利用npm（Node Package Manager，Node包管理器）社区的长处，建立一个简单的，但高可用的Web服务器，无需任何代码。这可以通过使用你刚刚在这里创建的树莓派系统，或在Windows/Linux/Mac机器上完成，正如我在一篇之前的文章中所概述的。希望再见到你！ 在树莓派上安装 Node.js 的指引 | thisDaveJ 本文转载自：众成翻译译者：qhxin链接：http://www.zcfy.cc/article/2090原文：http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/?utm_source=javascriptweekly&amp;utm_medium=email","tags":[{"name":"翻译","slug":"翻译","permalink":"http://qhxin.com/tags/翻译/"}]},{"title":"Virtual CSS 和 Styletron","date":"2016-12-17T10:41:43.430Z","path":"2016/12/17/fanyi/virtual-css-with-styletron/","text":"Styletron 是一个为了高性能而建立的 CSS-in-JS 的库，旨在运行得尽可能的快，同时尽可能小的输出 CSS。 大部分 CSS-in-JS 库将 JS 对象包含样式声明为相应的 CSS 类并使用生成的散列作为类名1。总的来说，这一过程运行良好，解决了大多数的CSS问题2。 Styletron 采取了不同的方法。它使用一个“虚拟CSS”引擎，抽象了底层的 CSS ，并启用一些强大的性能优化。 原子 CSS 和虚拟类关键的想法是，Styletron 把所有东西分解成唯一的声明，并且为每一个唯一属性值对创建一个对应的“原子CSS”类3，而不是生成简单地1:1映射到源样式对象的CSS类。结果就是，Styletron 可以对应的生成由几个原子类组成的虚拟类，而不是生成整块的样式。 这种抽象获得了几个性能优势： 非增长的样式最终在给定的应用里只有有限数量的不同字体大小，宽度和颜色。并且在实践中，为设计一致性的目的，这些选项经常被有意地限制在一组共用的值中，然后在应用中多次重复这些共用值。 Styletron 可以利用这点，因为它的虚拟 CSS 抽象在声明层面就去除了重复的样式，即使是不同的规则。在某种意义上，CSS 变成了非增长的：在某种程度上，新添加的样式实际上只是预先存在的声明的新排列，它映射到已经存在的原子类，生成CSS是零附加字节的。换句话说，虚拟 CSS 的 CSS 输出规模的大小由唯一样式声明的数量决定，而不是使用的样式的数量或频率。 在实践中，这会对尺寸产生巨大的影响，特别是在声明的总数远远超过唯一声明数目的大型网站。 最小的可能的样式CSS 优化的很重要的一点是把关键的和非关键的 CSS 分开，并且除掉没有使用的 CSS，这些没有使用的 CSS 白白浪费了浏览器的下载和解析。和许多其他的 CSS-in-JS 解决方案一样，Styletron 自动地在它的输出里面消除了任何没有使用的以及非关键的 CSS，只留下关键的CSS 给任何给定的服务器渲染的页面。 这通常是和它得到的一样好的，但是，即使是在消除了非关键的和未使用的 CSS之后，Styletron 还更进一步地减少了关键样式表的大小。虽然 gzip 通常是一个好的压缩样式表的方法，但在 Styletron里，所有的重复的声明都在 gzip 压缩之前被清理了。结果就是，浏览器可以更少地下载和解析，后者是不受 gzip 影响的。 此外，因为由 Styletron 生成的样式表是如此的小，他们能够很容易的内联到页面里去。这和页面的性能有关：确保移动设备上的快速加载时间，AMP 规范实际上禁止外部 CSS 资源，强制所有的 CSS 内联（有一个 50KB 的最大尺寸限制）。 很快的运行速度Styletron 是为高性能设计的，不仅在小的 CSS 输出方面，还有执行时间。和许多其他生产有限范围散列的 CSS 的 CSS-in-JS 库不一样，Styletron 不需要执行性能昂贵的哈希计算；相反，它生成的类由共享的、复用的、有序列化标识符的原子类组成4。此外，因为它是在个体的声明而不是整体规则上操作，Styletron 可以减少缓存未命中并且利用非常精细的记忆以避免不必要的工作。 程序基准测试css-in-js-perf-tests 库有许多针对大多数受欢迎的 CSS-in-JS 库的基准测试，包括 Aphrodite，Glamor，JSS，还有 Syletron。下面显示的数字是在我的 MacBook Pro 上用 Node7 运行基准测试的结果。 注：下面的 JSS 的基准测试表明没有使用默认预设，所以没有包含额外的如嵌套规则或第三方前缀。 渲染性能简单的样式测试 这个测试渲染少量的基础样式，一个是容器，一个是按钮。 样式过载测试 这个测试给n个不一样的按钮元素生成n个独有的样式，默认情况下n=20。 类过载测试 这个测试给n个不一样的按钮元素生成n个完全一样的样式，同样地，默认情况下n=20。 不像其他的库，Styletron 分解了规则，因此能够记住相同的声明，因此，在这个测试中的性能优势尤为明显。 CSS输出结果的大小作为一个大的 CSS-in-JS 应用的模拟，我使用uber.com和airbnb.com的CSS，转换这些样式为 JS 的等价对象，然后在 Styletron、JSS、Glamor 和 Aphrodite 里处理它们。以下是 CSS 输出文件的大小结果： uber.com CSS - 原文件 airbnb.com CSS - 原文件 一般来说，复用的样式越多，随着越来越多的 CSS 被去重，Styletron （和其他库比起来）生成的CSS越小。 JS 包大小（最小化的）Styletron 还是这些库里面最小的。它尽可能的被设计得小，而且客户端和服务端的包是分离的，这有助于减少臃肿。 用法实际的核心 Styletron 模块是非常低级的，这让它对于许多不同的 CSS-in-JS 接口是高适应性的，但直接使用是很笨重的。 最简单的方法是 Styletron 和 styletron-utils 包一起使用，styletron-utils 包包含各种方便功能，包括获取样式对象并返回相应虚拟类名的injectStyle。这个接口大致和其他 CSS-in-JS 库提供的接口一样。 最后，在最高水平，有一个 styletron-react 包，它有一个接口是受 React 优秀的 styled-components 模块启发的灵感。 参考 GitHub repo 和 styletron.js.org 可以了解更多。 已知问题和权衡后代选择器和子选择器是不受支持的 虽然在使用 React（样式与模板和渲染逻辑在一个地方）的时候这些东西不是经常地使用，它们在某些情况下仍然有用5。就是说，由于技术原因，这些可能不会在 Styletron 得到支持，至少在短期内。幸运的是，任何在 CSS 里由后代选择器和子选择器可以实现的效果都可以由渲染逻辑（JavaScript）实现。 至今没有降级处理 这是正在制定的问题，但目前没有实施。 本地工具的工作流的影响 使用虚拟类的一个结果是，当检查元素时，将在样式面板中看到每个声明的类，有时是很麻烦的。此外，在 Chrome 的本地开发工具里，客户端渲染的原子类是不变的——他们在元素上可以被打开和关闭，但是由于 Chromium 的 bug6 而不会改变。服务端渲染的样式是不受影响的，这个 bug 只影响 Chrome（Safari 和 Firefox 上表现得很好） 脚注 多数 CSS-in-JS 库，包括 Aphrodite、Glamor、JSS，等等。使用下面的方法： 类名称生成作用域的方法虽然不同，但这都是一个在生成的CSS类声明的集合之间 1:1 的映射。 ↩ Christopher Chedeau 的 开创性的介绍 CSS-in-JS 提供了一个良好的CSS缺陷概述以及在 JavaScript 中的样式怎么成为一个解决方案。 ↩ 这在概念上类似于 react-native-web 样式表模块（这实际上开创了为服务端渲染网页生成原子 CSS 的思想），但是 Styletron 以几个关键的方式使它更进一步： Styletron 为所有样式工作——静态和动态的都可以。react-native-web 样式表仅限于可以在渲染之外解决的静态样式。 react-native-web 样式表仅在服务端工作；在客户端，使用普通的 React 内联样式。 react-native-web 缺少媒体查询和伪类的支持, Styletron 支持这两者。 ↩ 使用确定性散列的一个原因是服务器和客户机渲染之间的一致性。因为 Styletron 的 CSS 输出仅由单一声明的原子类组成，它本质上是一个来自服务器的声明缓存的全序列化。因此，服务端渲染的 CSS 可以有效地反序列化，完全混合在客户端缓存的状态。 ↩ 后代选择器和伪类相结合是很有用的，最常见的用例是在父节点的悬停状态触发子节点的样式更改。然而，如果需要的话，这种行为可以在 JavaScript 中以事件监听和显式状态变化的方式得以实现。 ↩ 不幸的是，这个 bug 目前是被标记为不会修复。 ↩ Virtual CSS 和 Styletron 本文转载自：众成翻译译者：qhxin链接：http://www.zcfy.cc/article/1996原文：https://ryantsao.com/blog/virtual-css-with-styletron","tags":[{"name":"翻译","slug":"翻译","permalink":"http://qhxin.com/tags/翻译/"}]},{"title":"用React写了一个扫雷游戏","date":"2016-12-16T14:12:40.550Z","path":"2016/12/16/qianduan/saolei-in-react/","text":"学习了一下用React写UI，以及父子兄弟组件之间的通信，由于最近热衷扫雷，所以动手写了一个。 地址：http://qhxin.com/MyReact/www/SaoLei/index.html 整个界面分成了四个组件： 设计思路： 父组件是顶层容器，同时拥有标题栏，用户选择难度级别以及重置雷区的交互也是在这个组件上操作； 统计栏和扫雷区组件是顶层组件的子组件，它们俩是兄弟组件，单元格组件是扫雷区组件的子组件； 扫雷区组件会在父组件更改难度后，改变宽度，并且重新绘制所有单元格，重置地图和统计； 扫雷区组件会在父组件点击重置按钮后，重新绘制所有单元格，重置地图和统计； 单元格组件有鼠标左键以及鼠标右键事件操作，会相应的通知其他组件进行更新状态； 左键点击翻开一个格子吗，如果遇到周围地雷数目是0的单元格，会遍历周围8个格子，找到未打开并且不是雷的格子，触发左键点击，形成递归遍历。 总的来说还是挺简单的。扫雷还是挺有意思。最近玩扫雷着了魔。","tags":[{"name":"前端","slug":"前端","permalink":"http://qhxin.com/tags/前端/"}]},{"title":"开始尝试React的感受以及遇到的问题","date":"2016-12-14T14:40:08.400Z","path":"2016/12/14/qianduan/try-react/","text":"一些废话作为一个技术偏向后端、然后半路开始做一些前端的事情，另外性格比较保守的人，之前一直是用jQuery在做前端，基本上也够用，但是也有在工作中思考一些前端的东西。因为公司的技术栈已经切换为React，随着旧版本的下线，以后应该会经常和它打交道了。 因为产品的原因，jQuery开发的旧系统确实很难维护，常常改一个地方要考虑非常多的影响。原因呢，旧系统的代码的组织上比较混乱是一方面，另外就是业务逻辑很繁杂，耦合度非常高，很难扩展或复用，还有一些地方已经完全没有人记得当初为什么要这样做，以及这个逻辑究竟在干啥。所以利用老大们去重构的这段过渡时间，我也做了一些准备。 在我本意，我是不太支持使用太多工具来搞前端的，毕竟简单好用才是最棒的。但问题是目前前端的技术栈并不是太简单，最近几年有很多新事物新玩意被制造出来，又被淘汰，你根本拿不准什么时候社区就丢弃某些你所依赖的东西了，在这样一个不稳定阶段选择一个靠谱的工具是很令我这种对前端社区不太熟的人很感到焦虑的。 虽然我对社区的动向不是很熟悉，但毕竟还是写了这么久的代码，经过这些年对前端的观察和实践，其实我觉得我只需要这么一些东西即可： 代码压缩打包工具，这个可以节省带宽和连接数，很实用； 模块化、组件化、数据和视图分离的规范； 处理兼容性的javascript的库，jQuery啦； 其实就这几点，很简单，目前代码压缩和打包是有了的，jQuery也是必须的，那剩下的就是组件化了。实际上，我也在用组件化的思想编程，不过没有像React那样使用虚拟dom来diff更新，也没有用过模板，简单的用数组来拼接用做视图。不过在尝试了React做视图之后，确实觉得还是很方便，毕竟封装了一些需要我手写的东西，特别是jsx的写法，确实很方便。 目前还没有使用数据流什么的，因为这里是比较有争议的，有人说单向好，有人说双向好，其实我更倾向于双向数据流，业务决定技术选型嘛，再有就是做视图就专心做视图，没必要搞那么臃肿，所以我对React、以及ES的其他一些高级特性以及语法糖目前不是很感兴趣。 问题说说遇到的几个问题： 1. 嵌套组件互相调用方法导致无限回调这个问题是由于我为了在父子组件之间进行沟通，子组件在 render 时调用了一些 props 里设置的父组件的回调方法，然后在这个回调函数里更新 state，结果就是在render的时候，触发了子组件的 componentWillReceiveProps 方法，因为我在这里做了一些针对 props 改变时更新子组件的 state 的事情，于是构成了一个无限的回调，直至JS报错，汗~~ 2. refs 的成员在未插入DOM时是不存在的在子组件A上设置了一个ref，供父组件的方法找到它，另外有一个子组件B，会通知父组件一些事情，然后父组件让组件A来显示。我一开始只在子组件B的getInitialState计算完state初始值的时候就通知父组件，结果就是它的refs里面找不到组件A，原因是需要组件真实被插入DOM之后，才会添加ref到refs里面去，所以应该在componentDidMount的时候再去触发这个通知。以后也应该注意这个问题。 3. this.setState()只有用this.setState设置state才会更新 render ，直接赋值是不行的。 总结上面这些问题是因为不熟练造成的，并不是致命问题。总的来说React还是比较简单的，用着也比较顺手，效率较高，适合我们的业务。","tags":[{"name":"前端","slug":"前端","permalink":"http://qhxin.com/tags/前端/"}]},{"title":"珍珠翡翠白玉汤","date":"2016-12-12T13:10:51.250Z","path":"2016/12/12/sushi/fei-cui-bai-yu-tang/","text":"原料：豆腐200克、毛豆50克、娃娃菜100克、植物油1汤匙、盐1茶匙、香油1茶匙 做法： 毛豆洗净、豆腐切块、娃娃菜洗净取菜心 分别将毛豆和豆腐焯水 煮锅内放入水，加入少量植物油，煮沸 放入豆腐，毛豆 再次沸腾后放入娃娃菜心煮软 加入盐调味，淋一点香油即可 小贴士：娃娃菜富含维生素和硒，叶绿素含量较高，具有丰富的营养价值。娃娃菜还含有丰富的纤维素及微量元素，也有助于预防结肠癌。","tags":[{"name":"素食","slug":"素食","permalink":"http://qhxin.com/tags/素食/"}]},{"title":"JavaScript的严格模式，以及为什么你应该使用它","date":"2016-12-12T07:41:35.660Z","path":"2016/12/12/fanyi/javascripts-strict-mode-and-why-you-should-use-it/","text":"从 ECMAScript 5 开始，开发者能够将他们的代码转换成一个更受约束的执行形式——strict mode。严格模式通过强制更好的编程实践和消除一些语言的不安全和不明智的特点，提高了JavaScript代码质量。通过向您的代码添加以下指令，可以启用严格模式： 1&quot;use strict&quot;; “use strict”;指令可以用两种方式使用。唤起严格模式的第一种方法是在文件级别上。通过在文件开始的位置添加这个指令（该指令只能在注释和空格之前），在全局上下文内启用严格模式。这意味着你所有的代码都将在严格模式下进行解析。当严格模式和非严格模式的脚本在一起使用时，一定要注意一下。当严格模式的脚本在前面的话会强制非严格模式的脚本在严格模式下解析。当非严格模式的脚本在前面时则会导致相反的行为。这会导致一些和 Amazon 一样的问题。 第二种方法是在函数级别上使用严格模式。将“use strict”;指令放置在函数体开头，可以启用这个级别的严格模式。与全局严格模式一样，这个指令只能在空格和注释之前。在函数级使用严格模式允许程序员在同一文件中混合和匹配严格模式的和非严格模式的函数。当一些遗留代码依赖于已经过时的被严格模式弃用的特点时这是很有用的。 12345678function foo() &#123; &quot;use strict&quot;; // 此函数是在严格模式下执行的&#125;function bar() &#123; // 此函数是在非严格模式下执行的&#125; 关于严格模式的一个好的东西是它的向后兼容性。老版本的JavaScript会视“use strict”;指令为一个无意义的字符串并忽略它。而新版本的JavaScript会对这个声明进行特殊处理并切换到严格模式。对于支持严格模式的浏览器，会有以下约束。 隐式全局变量声明JavaScript 有一个有趣的处理变量声明的方法。没有使用 var 关键字声明的变量会被隐式声明为全局变量。下面的代码使用了三个变量——“x”，“y”和“z”。 12345678function foo() &#123; var x; var z; x = 1; y = 2; z = x + y;&#125; 注意，只有变量“x”和“z”声明使用 var 关键字。有一个足够的可能性是，程序员也打算声明“y”，但错误地没有。该代码将正确执行，但具有副作用，它会创建一个名字叫做“y”、值为2的全局变量。因为 window 是全局对象，这相当于写： 1window.y = 2; 这种行为可能是有问题的，如果“y”已经定义在其他地方，且有一个不同的值。这导致代码伸缩性不太好，并且很难调试。启用严格模式将捕获这个问题。会发生一个异常，而不是使“y”成为一个全局变量。在 Chrome 中显示的异常看起来像这样： 1ReferenceError: y is not defined With 语句With 语句提供了一种用于工作对象属性的速记符号。在 with 语句内部，很难说一个变量是属于 with 使用的对象还是其他范围的对象。下面的代码使用一个 with 语句来输出文档的标题。这里有一个本地变量也叫 “title”，它在 with 语句里面是被忽略的。在一块更复杂的代码里，程序员在使用 with 语句时会很容易犯与变量作用域相关的错误。 1234567function foo() &#123; var title = &quot;Not the page title&quot;; with (document) &#123; write(title + &quot;&lt;br /&gt;&quot;); write(&quot;contains a with statement&quot;); &#125;&#125; 在严格模式下，with 语句被完全的禁用了。任何试图使用 with 语句的尝试都将导致下列语法错误。注：一个更好的主意是将对象赋值给一个变量，并通过变量来访问它的属性。 1SyntaxError: Strict mode code may not include a with statement 标识符的命名严格模式在变量、函数和参数上有几个命名限制。字符串“eval”和“arguments”不能用作标识符，他们也不能有赋值。因为JavaScript内置了一个“eval”函数和“arguments”的对象，这消除了可能的混乱。尝试使用“eval”或“arguments”作为名称的结果就是下面的异常： 1SyntaxError: Variable name may not be eval or arguments in strict mode 此外，标识符不能使用任何以下为未来保留的关键字： implements interface let package private protected public static yield this 的用法使用“this”变量在面向对象编程中很常见。在一个函数中，“this”变量指向拥有函数的对象。然而，当一个函数不属于任何特定的对象时，“this”变量指向全局对象（window）。严格模式通过赋值给“this”一个未定义的值，移除全局对象的意外或恶意访问。如果一个函数是由一个对象拥有的，那么“this”仍然如预期的一样指向该对象。在下面的例子里，函数“foo”返回undefined。 1234function foo() &#123; &quot;use strict&quot;; return this;&#125; 只读属性JavaScript 允许开发者在对象上创建只读的属性。试图在非严格模式代码中写入一个新值到只读属性会静默地失败。换言之，该属性的值保持不变，但该程序不提供任何警告或错误。在严格的模式下，这样的行为会导致脚本抛出一个异常。下面的示例创建一个名为“prop1”只读属性。在严格模式下，后续对“prop1”的赋值导致一个 TypeError 异常。 1234567891011function foo() &#123; &quot;use strict&quot;; var obj = Object.defineProperties(&#123;&#125;, &#123; prop1 : &#123; value : 1, writable : false &#125; &#125;); obj.prop1 = 2;&#125; 不可扩展的对象和变量在 JavaScript 中，添加新的属性到对象是微不足道的——只是赋一个值给它就行了。JavaScript 还提供了一种防止新的属性添加的机制。通过将一个对象的内部“extensible”属性设置为 false，对一个对象的新属性的添加将静默失败。再次，严格模式会将静默的失败改为 TypeError 异常。下面的代码试图将一个新属性添加到一个非可扩展的对象中。 1234567function foo() &#123; &quot;use strict&quot;; var obj = &#123;prop1 : 1&#125;; Object.preventExtensions(obj); obj.prop2 = 2;&#125; 对象“obj”由一个属性“prop1”构造，当“Object.preventExtensions”被调用时，“obj”变为不可扩展。尝试给对象添加“prop2”属性的结果是导致下面的异常： 1TypeError: Can&apos;t add property prop2, object is not extensible 重复参数和属性非严格模式的 JavaScript 允许对象包含多个具有相同名称的属性。当相同的名称被使用多次时，只有最后一个声明被使用了。严格模式要求所有的属性名称都是唯一的。在下面的例子中，对象“obj”包含两个名为“prop1”的属性。在非严格模式下，“prop1”的值会是3。然而，当严格模式开启时，这会出现一个语法错误。 123456// 在严格模式下obj = &#123; prop1 : 1, prop2 : 2, prop1 : 3&#125;; 类似的，非严格模式下的函数可以有多个参数具有相同的名称。在严格模式下，这是不被允许的。在下面的例子中，重复的“param1”导致一个语法错误。 1234function foo(param1, param1) &#123; &quot;use strict&quot;; alert(param1);&#125; eval 变量 非严格模式的代码可以使用“eval”函数来添加新的变量到当前作用域。在浏览器的原生JSON支持之前，“eval”普遍的（和安全的）用于从字符串构造对象。构造的对象会成为当前作用域的一部分。在严格模式下，“eval”不能引入新的变量。当执行在严格模式下时，下面的代码不会将“bar”变量引入当前作用域。注意：如果一个含有“eval”的函数是在严格模式下执行，那么在“eval”函数里的代码也在严格模式下执行。 12// 在严格模式下eval(&quot;var bar = 10;&quot;); 删除操作删除运算符用于从对象中删除属性。然而，一些属性是不能被删除的。不可配置的属性就是属于不能被删除的。非严格模式的代码将在尝试删除不可配置的属性时静默失败。这种尝试会在严格模式下执行时抛出 TypeError 异常。在下面的例子中，对象“obj”有一个叫做“prop1”的不可配置的属性和一个叫做“prop2”的可配置的属性。因为“prop2”是可配置的，所以删除它是完全可以接受的。直到试图删除“prop1”之前是没有异常被抛出的。 12345678910111213141516function foo() &#123; &quot;use strict&quot;; var obj = Object.defineProperties(&#123;&#125;, &#123; prop1 : &#123; value : 1, configurable : false &#125;, prop2 : &#123; value : 2, configurable : true &#125; &#125;); delete obj.prop2; delete obj.prop1;&#125; 删除运算符是刻意只对对象的属性起作用的。当试图去删除普通变量和函数时会出现语法错误。下面例子中所有的删除操作都会失败。 123456789function foo(param1) &#123; &quot;use strict&quot;; var bar = 1; function baz() &#123;&#125;; delete param1; delete bar; delete baz;&#125; 使用 arguments，caller，和 callee当一个函数被调用，一个名为“arguments”的特殊对象会在函数的作用域被创建。“arguments”是一个包含了传给函数的所有参数的类数组对象。在下面的例子里“arguments[0]”和“arg1”持有同样的值，“arguments[1]”和“arg2”亦然。在非严格模式下，更新一个值会自动更新它所映射到的值。在“bar”结束时，“arg1”和“arg2”的值已经交换，即使值只赋值给了“arguments”数组。在严格模式下，别名值不会自动更新。因此，严格模式下运行，在“bar”结束时，“arg1”和“arg2”的值不会改变。 12345678910function foo() &#123; bar(1, 2);&#125;function bar(arg1, arg2) &#123; var temp = arguments[0]; arguments[0] = arg2; arguments[1] = temp; alert(arg1 + &quot; &quot; + arg2);&#125; “arguments”对象还包含一个指向当前正在执行的函数的指针。当前函数称为被调用方，可被“arguments.callee”引用。这个语法只能在匿名函数内部使用，因为匿名函数没有名字。在任何其他情况下，用名字来引用被调用函数更有意义。在严格模式下，访问“arguments.callee”是不被允许的。 有一个类似的方法可以用来确定函数调用是从哪里来的。在旧的浏览器里有一个“arguments.caller”对象是可用的，但是它已经被弃用了。然而，调用方法仍然可以使用“arguments.callee.caller”来被确定。严格模式也禁止访问这个调用方对象。在下面的例子中，“bar”没有在严格模式中。然而，试图访问“arguments.callee.caller”依然会失败，因为“foo”是一个在严格模式下的函数。 12345678function foo() &#123; &quot;use strict&quot;; bar(1, 2);&#125;function bar(arg1, arg2) &#123; var caller = arguments.callee.caller&#125; 更新 (11/21/14)启用严格模式可以允许一些 JavaScript 引擎诸如 v8，去优化代码，否则不会。在非严格模式下，在同一个函数里引用“arguments”和一个已命名参数会导致 v8 不去优化这个函数。稍微更详细的阅读，可以看这个问题以及我个人的 will-it-optimize 项目。 更新 (11/21/14)我也要感谢 Chris Dickinson 提供了一个很好的（我觉得是）严格模式阻止的坏的编码实践的案例。下面的例子在非严格模式下返回 102，但是在严格模式下，当一个函数试图重写另一个函数的参数时，会抛出一个错误。 123456789101112// &quot;use strict&quot;; // 取消注释这行会看到一个错误function modify() &#123; poison.arguments[0] = 100;&#125;function poison(a, b) &#123; modify(); return a + b;&#125;console.log(poison(1, 2)); 八进制八进制变量用八进制来表示数字。他们很少被使用，并且有一个非常容易使人混淆的语法。正的八进制数由“0”作前缀，负的八进制数由“-0”作前缀。举个例子，定义一个八进制的 100 看起来就像这样： 1var foo = 0100; 由于人们往往忽略前导零，这可以很容易地与十进制 100 混淆。然而，一个简短的调用“parseInt()”表明这个八进制值实际上等于转换为十进制时的64。为了解决这个问题，严格模式不允许使用八进制。在严格模式下，八进制的变量和八进制转义序列都被视为语法错误。 分享这篇文章: Facebook Twitter Google JavaScript的严格模式，以及为什么你应该使用它 | Colin J. Ihrig的博文本文转载自：众成翻译译者：qhxin链接：http://www.zcfy.cc/article/1986原文：http://cjihrig.com/blog/javascripts-strict-mode-and-why-you-should-use-it/","tags":[{"name":"翻译","slug":"翻译","permalink":"http://qhxin.com/tags/翻译/"}]},{"title":"你无法检测到触摸屏","date":"2016-12-11T02:32:03.540Z","path":"2016/12/11/fanyi/you-cant-detect-a-touchscreen/","text":"更新: 我不知何故忽略了提及Modernizr.touch，它实际上使用了下面提到的 “Touch APIs”。 Modernizr声称不再检测触摸设备——可以看看这个讨论。 无论你可能会怎么想，目前，在浏览器里可靠地检测当前的设备是否有一个触摸屏是不可能的。 并且可能会在很久很久以后你才能做这个检测。 让我解释一下这样说的原因…… 在沙盒中 ¶浏览器的环境是一个沙盒。为了限制恶意网站可能造成的伤害，你的应用的代码只能获得浏览器想给你的东西。 这意味着，你可以得到的系统的唯一信息是浏览器以HTML，CSS和JavaScript API的形式向你公开的那些。确定一个系统是否支持某个功能，我们能做两件事，一是看某个明确的API是否存在，或者第二，看它是否真的做了正确的事情。 从历史上看，有两个浏览器的功能已被用于“触摸屏检测”：媒体查询 和 Touch APIs。但这些离做到万无一失还很遥远。 跟我一起看下去。 设备宽度媒体查询 ¶手机拥有小屏幕，并且手机拥有触摸屏，所以小屏幕等于触摸屏，这正确吗？ 1var hasTouch = window.matchMedia(&apos;(max-device-width: 320px)&apos;).matches; 所以，这是非常错误的看法。大平板电脑和触屏笔记本电脑/台式机已经明显的证明了这是错的。再加上还有成千上万的旧的手机型号有小的非触摸屏。但不幸的是，现在到处都有应用这条咒语的网站：“如果这是一个小屏幕，它就是触摸屏；如果这是一个大屏幕，它就是由鼠标操作的”，把垃圾的体验留给平板和多端用户。 Touch APIs ¶顺便说一句，这是 Modernizr.touch 使用的方法。 如果浏览器支持一些事件诸如touchstart（或者其他在 Touch Events 事件接口标准的事件），这一定就是一个触屏设备，对吗？ 1var hasTouch = &apos;ontouchstart&apos; in window; 好吧，或许是这样。但问题是，从来没有人说过一个非触屏设备不能实现触摸接口，或者至少在 DOM 里拥有事件句柄。 Chrome 24.0 装载支持了所有这些接口，所以它们可以开始支持触摸屏而不需要分为“触屏”和“非触屏”来构建。但是大量开发者依然在使用上面例子中的检测方法，所以这损坏了大量网站。Chrome 团队用一次升级“修复”了这个问题，它只在当启动时检测到了可触摸输入设备时才启用触摸接口。 所以我们都没问题了，对吧？ 不完全是。 接口的接口 ¶对于设备本身，浏览器仍然有相当远的距离。它只能通过操作系统来使用设备，而操作系统有自己的一堆接口让浏览器知道设备连接上了。 虽然这些接口在大多数情况下是相当可靠的，但在我们最近遇到的情况下，他们在 Windows 8 的 Chrome 里给出了错误的结果……他们报告了一个触摸屏的存在（其实是“数字转换器”），其实并没有连接触摸屏。 Firefox 也做了一些类似的转换，并且同样在这种情况下和 Chrome 一样表现为了失败，所以看起来它也可能使用了和 Chrome 一样的规则——虽然我不能肯定的断言。 毫无疑问，设置和服务会混淆接口返回的结果。到目前为止我只在 Windows 8 里看到这种情况，但从理论上讲，它可以发生在任何操作系统。 一些 BlackBerry OS 的版本也已被知道在非触摸设备上持久启用了触摸的接口。 所以看起来浏览器也不能百分之一百的确定检测触屏设备。如果浏览器都不知道，那我们的应用又怎么知道呢？ 没有结果 ¶假设有一个这些触摸接口存在就意味着这个设备有一个触摸屏……那是否意味着如果没有触摸接口存在，那触摸屏也一定不存在？ 当然不是。最初的 iPhone （在2007年发布）是第一个支持 Touch Events 的设备，但是，从二十世纪70年代开始触摸屏已经以一种或另一种形式存在。甚至就算最近，诺基亚的塞班浏览器也不支持触摸事件，直到去年 8.2 版本的发布。 IE 10 在触摸设备上提供（可以说是优越的）Pointer Events API，用来代替 Touch Events 标准，所以会在测试ontouchstart时返回false。为了覆盖所有基线你也可以做这些检查例如&#39;onmspointerdown&#39; in window——虽然这会很容易的像 Chrome 和 Firefox 一样受到系统接口可靠性的影响。我说的不对，onmspointerdown还和鼠标和其他指针有关。然而 IE 10 提供了navigator.maxTouchPoints可以用来代替利用。感谢 @jacobrossi指正我。 不管是 Safari 还是 Opera 都还没有在他们的桌面浏览器实现触摸接口，所以他们在触摸设备上也没有结果。 没有专门的触摸接口，浏览器仅仅模拟鼠标事件……因而有许多设备和触摸屏不等同，你根本不能用这些检测方法来检测这些设备。 这是动态的, Jim ¶一个触摸屏可以作为一个外围设备连接到另一个非触摸式笔记本电脑，或者一个 KVM 开关可以从非触摸屏切换到触摸屏。这可以在浏览器会话过程中的任何时间发生。 当应用在执行时，浏览器不应该添加和移除接口——这会造成混乱——所以随着已连接设备的变化，这种特性检测可能出现失败。 戳它 ¶我之前说，另一种方法来测试特性是看接口是否真正的完成了他们支持的功能…… 123456var hasTouch;window.addEventListener(&apos;touchstart&apos;, function setHasTouch () &#123; hasTouch = true; // 当事件触发后，将事件监听移除，否则它会干掉滚动性能 window.removeEventListener(&apos;touchstart&apos;, setHasTouch);&#125;, false); 这是比简单地看是否这个事件句柄在 DOM 上存在更加可靠的方法：除非这个浏览器大量的违反了标准，如果一个触摸捕获设备与浏览器交互，这个事件会被触发。 然而，这产生了三个严重需要注意的事项： 在你知道结果之前，它需要有交互发生； 如果没有触摸交互发生，你不知道这是因为没有触摸屏——（还是）仅仅是用户没有使用它； 这个事件在不支持 Touch Events API 的浏览器里依然不会触发……而这是大部分情况。 这或许对于一些使用场景已经足够好了，但是对于任何涉及修改布局的应用来说，当你戳它的时候，UI 会发生改变，这是一个相当可怕的使用体验。 指针媒体查询 ¶它们被添加到 Media Queries Level 4 标准。他们只是在 WebKit 内被部分地实现，还没有出现在任何稳定的浏览器里。 1var hasTouch = window.matchMedia(&apos;(pointer: coarse)&apos;).matches; 关于这个规范的细节在之前我有一个鲁莽的结论，但它实际上有可能被用作一个可靠的特征检测。不需要思考：它没有检测一个“触摸屏”例如……而是任何普遍的指针设备。 作为媒体查询，它自然是动态的：结果可以在任何时候即时反映连接的设备。 然而，它依然依赖于操作系统接口提供可信的数据。 目前还不清楚何时（或是否）其他浏览器将实现此功能……这个标准在 W3C 都还非常不稳定。在它广泛采纳之前，不支持这些媒体查询的浏览器们会一直像现在这样“不可检测”。 你这样做是错误的 ¶我认为，如果你在最开始的时候就在试着“监测触摸屏”，你很可能已经在做危险的假设。我将详细列出你想要监测屏幕的几个可能原因，并指出其中的错误。 手指友好的布局 ¶胖手指比鼠标更不准确，所以听起来我们适应触摸屏布局是有道理的：较大的控件，控件之间更多的空隙，等等。 但触摸屏是唯一的具有较差的指点精度的输入设备吗？ 那智能电视的手势遥控器、Wii游戏机的遥控手柄，或者类似 Leap Motion 的手指跟踪技术又怎么样呢？ 如果你特希望触屏检测在这些设备上不会过时，千万别假定在监测屏幕时只需做好空间布局就够了。 事件和交互 ¶所以你想要为你的幻灯效果和地图窗口部件设置滑动手势吗？这很酷。但是不要认为这意味着你不需要支持鼠标和键盘交互。 有视力障碍的用户经常在他们的智能手机上连接键盘和点击设备，这样许多设备都同时支持鼠标和触摸……你不能假设他们不想使用他们的鼠标、触控板以及键盘。 我强烈建议一起实施两种交互方法，在这种情况下，你不需要专门检测触摸屏。 Patrick Lauke 的这篇文章更加详细地提出了为什么（以及怎么做）你应该一起实现鼠标和触摸事件。这篇文章很值得一读（如果你原谅他最初声称你可以可靠地检测到触摸屏……）。 悬停状态的处理 ¶当前的触摸屏并不能传输鼠标/光标悬浮状态, 所以，最好调整我们对于触摸屏的UI设计，以便在触摸屏上能够继续使用。 当然，键盘也是不能悬停的。最好一开始就避免依赖于悬停状态——仅使用它们作为点缀。 所以我应该做什么？ ¶修改: 这个总结分散了这篇文章的原始信息，就是“小心，你可能没有得到你认为你得到的结果”。如果你意识到这些检测方法的风险和他们所暗含的臆断，不管怎么样，这当然是由你决定是否使用他们。然而，如果你不确定，或你的论点是“支持每一个设备”，下面的建议可能是有用的。 关于布局，假设每个人都有触摸屏。鼠标用户们使用大的控件比触摸屏用户们使用小控件更加容易。悬停状态也是一样的。 关于事件和交互，假设任何人可能有触摸屏。同等的实现键盘，鼠标和触摸交互，确保没有阻止彼此。 或者，就像我在我的关于媒体查询的文章里建议的一样，你可以只询问浏览器。 本文转载自：众成翻译译者：qhxin链接：http://www.zcfy.cc/article/1973原文：http://www.stucox.com/blog/you-cant-detect-a-touchscreen/","tags":[{"name":"翻译","slug":"翻译","permalink":"http://qhxin.com/tags/翻译/"}]},{"title":"发布 GitHub Pages，现在就像数 1, 2, 3 那样简单 · GitHub","date":"2016-12-11T02:28:37.060Z","path":"2016/12/11/fanyi/publishing-with-github-pages-now-as-easy-as-1-2-3/","text":"在 GitHub Pages 发布网站或者软件文档现在只需要更少的步骤——精确来说是三步： 创建一个 GitHub 仓库（或者选择一个已经创建好的仓库）； 像你提交其它任何文件一样，通过 GitHub 的网页提交一个 Markdown 文件； 在你的仓库设置那里激活 GitHub Pages 。 就像这样就行了——你现在已经拥有了一个网站。如果你已经对 GitHub Pages 熟悉了，你或许会对知道一些幕后的东西感兴趣，我们现在正在做一些事情去简化这个发布流程，并且让它更加如你所期待的那样在 GitHub 的其它地方创作 Markdown 内容。 所有的 Markdown 文件现在都被 GitHub Pages 渲染，把你从需要给每个文件添加 YAML 前置描述（在文件顶部由---符号分割的元数据）中解脱出来。 如果你没有一个名为index.md（或者index.html）的文件，我们会使用你的 README 文件作为站点的首页，就和你在 GitHub 浏览一个仓库时看到的一样。 如果你没有在你的站点配置文件里指定主题（或者根本就没有站点配置文件），我们将设置一个最小化的、和其它在 GitHub 上的 Markdown 文件的外观及体验相匹配的默认主题。 如果一个给定的文件没有明确的指明使用什么布局，我们将根据它的上下文指定一个。举个例子，页面会自动的变成page布局，而如果page布局不存在，它会变成default布局。 如果你的页面没有一个明确的标题，并且这个文件是由 H1、H2或者 H3 标签开始的，我们会使用这个标签内容作为页面的标题，显示在浏览器的标签上。 这些改进应该能让你更快更简单的通过几次点击发布你的第一个（或者第一百个）网站，或者通过简单地添加 Markdown 文件到/docs目录 ，在仓库内给你的软件项目编写文档。当然，你依然可以通过额外的自定义设置（比如使用你自己的布局和样式来覆盖默认主题）来继续控制外观和体验。 虽然这些改动应该不会影响大多数现有站点的建设，但对于早期的 Jekyll 用户来说有两个潜在的陷阱： 如果你的站点遍历了所有页面（例如，for page in site.pages），你可能会发现现在有额外的页面（比如第三方依赖库的 README 页面）在这个列表里。你可以使用配置文件里的exclude配置显式地排除这些文件。 如果你没有指定一个页面的布局和标题，并且希望它一直保持这样（例如，假如你需要提供无样式的内容），你需要明确地将这些配置的值设为null。 如果出于任何原因你不想使用这些特性，你可以通过添加一个.nojekyll文件到你的站点根目录来禁用它们。 所以， GitHub Pages 生成过程是可以尽可能透明和可定制的，所有上面提到的特性都是以 Jekyll 的开源插件的形式实现的，也就是 Jekyll Optional Front Matter , Jekyll README Index ， Jekyll Default Layout ，以及 Jekyll Titles from Headings 这些插件。 再者，这些变化不应该影响大多数现有站点的建设（虽然你可以安全的开始使用这些特性），但是如果你有任何问题，请联系我们。 三步发布快乐！ 本文转载自：众成翻译译者：qhxin链接：http://www.zcfy.cc/article/1970原文：https://github.com/blog/2289-publishing-with-github-pages-now-as-easy-as-1-2-3","tags":[{"name":"翻译","slug":"翻译","permalink":"http://qhxin.com/tags/翻译/"}]},{"title":"简单计算任意数的平方根","date":"2016-12-08T14:46:43.000Z","path":"2016/12/08/jingyan/kaipingfang/","text":"最近学到一个单间计算任意数的平方根的方法； 计算√(X)，则√(X) = √(A)*√(X/A) = √(A)*√(1+(X-A)/A)。再用泰勒级数里面，当x接近0时，√(1+x)≈1+x/2。可以得到一个近似值： √(X) ≈ √(A)*(1+(X-A)/(2*A)) = √(A)+(X-A)/(2*√(A)) 例子：比如计算一个数38的平方根，先找到离他最近的那个小一些的能开方的数，即36。然后按照这个方法得到近似值： √38 = √36*√(1+2/36) ≈ 6*(1+2/36/2) = 6+2/6/2 = 6.17 真实的√38 = 6.164，这个结果算是比较接近了。","tags":[{"name":"经验","slug":"经验","permalink":"http://qhxin.com/tags/经验/"}]},{"title":"不要把钥匙别裤腰上","date":"2016-12-04T14:21:58.620Z","path":"2016/12/04/jingyan/yaoshifangzhi/","text":"很久以前，一位师兄教导我，成熟的男人是不应该把钥匙别在裤腰上的。当时不明白，后来去查了，是社交礼仪的规定。我一向不在意这些什么礼仪，对此不以为然，不过后来为了方便，还是将钥匙放在了包里。 今天为了方便，没有带包，将钥匙挂在裤腰上，出去浪了一天。回来后发现，钥匙尽然弯了，弯了~弯了~弯了！我靠，折腾了很久才勉强掰正，差点就进不了屋。 所以为了避免今后出现坐在车里把钥匙坐弯，以及被钥匙串伤害，以后应该不怕麻烦，坚决带包。 所以，将钥匙放在包里，总结为三点好处： 1、不伤害钥匙；2、不伤害自己；3、不会失误搞掉；","tags":[{"name":"经验","slug":"经验","permalink":"http://qhxin.com/tags/经验/"}]},{"title":"病中偷闲，重新把博客搞起来","date":"2016-12-02T10:41:42.200Z","path":"2016/12/02/suibi/bingzhong/","text":"前段时候，忙于一些事情，没有管理好博客。VPS过期后，也没去管理，结果就是以前积累的文章都丢失了，备份都找不到，索性直接重新搞吧。 本来打算还像以前一样用typecho+next主题来做，后来觉得实在没有必要去折腾这些东西，加上最近身体不好，精力欠乏，最后还是决定用hexo。选用了Theme Yilia by Litten，挺大气的一个主题，比较喜欢。 生病一周多了，得多喝水，晚上再去看医生，希望尽快好起来。一个人在这个城市，生病是件很难受的事情，幸好有同事朋友关心，很感谢！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://qhxin.com/tags/随笔/"}]},{"title":"Hello World","date":"2016-12-01T11:01:27.650Z","path":"2016/12/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]